{
  "version": 3,
  "sources": ["src/app/services/auth.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { BehaviorSubject, Observable, of, throwError } from 'rxjs';\nimport { catchError, tap, retry, timeout } from 'rxjs/operators';\nimport { User } from '../models/user.model';\n\nexport interface ApiError {\n  timestamp: string;\n  status: number;\n  error: string;\n  message: string;\n  path: string;\n  errors?: { [key: string]: string };\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  private readonly API_URL = 'http://localhost:8080/api';\n  private readonly REQUEST_TIMEOUT = 10000; // 10 seconds\n  \n  private currentUserSubject = new BehaviorSubject<User | null>(null);\n  public currentUser$ = this.currentUserSubject.asObservable();\n  \n  // Store token in memory instead of localStorage for security\n  private authToken: string | null = null;\n\n  constructor(private http: HttpClient) {\n    this.loadUserFromToken();\n  }\n\n  private loadUserFromToken(): void {\n    // Try to get token from cookie on page load\n    const token = this.getTokenFromCookie();\n    if (token) {\n      this.authToken = token;\n      this.getCurrentUser().subscribe({\n        error: (error) => {\n          console.warn('Failed to load user from stored token:', error);\n          this.removeToken();\n        }\n      });\n    }\n  }\n\n  private getTokenFromCookie(): string | null {\n    const name = 'auth_token=';\n    const decodedCookie = decodeURIComponent(document.cookie);\n    const ca = decodedCookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1);\n      }\n      if (c.indexOf(name) === 0) {\n        return c.substring(name.length, c.length);\n      }\n    }\n    return null;\n  }\n\n  getToken(): string | null {\n    return this.authToken;\n  }\n\n  setToken(token: string): void {\n    if (!token || token.trim() === '') {\n      console.error('Attempted to set empty or invalid token');\n      return;\n    }\n    this.authToken = token;\n  }\n\n  removeToken(): void {\n    this.authToken = null;\n    // Clear the cookie by setting it to expire\n    document.cookie = 'auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';\n  }\n\n  isAuthenticated(): boolean {\n    const token = this.getToken();\n    return !!token && token.trim() !== '';\n  }\n\n  getCurrentUser(): Observable<User | null> {\n    const token = this.getToken();\n    if (!token) {\n      return of(null);\n    }\n\n    const headers = new HttpHeaders().set('Authorization', `Bearer ${token}`);\n    \n    return this.http.get<User>(`${this.API_URL}/auth/me`, { headers }).pipe(\n      timeout(this.REQUEST_TIMEOUT),\n      retry(1),\n      tap(user => {\n        if (user) {\n          this.currentUserSubject.next(user);\n        }\n      }),\n      catchError((error: HttpErrorResponse) => {\n        console.error('Error fetching current user:', error);\n        \n        // Handle different error scenarios\n        if (error.status === 401 || error.status === 403) {\n          console.warn('Authentication failed, logging out user');\n          this.logout();\n        } else if (error.status === 0) {\n          console.error('Network error - server may be unavailable');\n        } else {\n          console.error('Unexpected error:', error.message);\n        }\n        \n        return of(null);\n      })\n    );\n  }\n\n  login(provider: 'google' | 'github'): void {\n    if (!provider || (provider !== 'google' && provider !== 'github')) {\n      console.error('Invalid OAuth provider:', provider);\n      return;\n    }\n    \n    this.redirectToOAuth(provider);\n  }\n\n  private redirectToOAuth(provider: string): void {\n    try {\n      window.location.href = `${this.API_URL.replace('/api', '')}/oauth2/authorization/${provider}`;\n    } catch (error) {\n      console.error('Error redirecting to OAuth provider:', error);\n    }\n  }\n\n  handleAuthCallback(): void {\n    // Token is now in cookie, just load user\n    this.getCurrentUser().subscribe({\n      next: (user) => {\n        if (user) {\n          console.log('User authenticated successfully:', user.email);\n        }\n      },\n      error: (error) => {\n        console.error('Failed to fetch user after auth callback:', error);\n        this.logout();\n      }\n    });\n  }\n\n  logout(): Observable<{ message: string }> {\n    const token = this.getToken();\n    \n    // Clear local state immediately\n    this.removeToken();\n    this.currentUserSubject.next(null);\n    \n    // Notify server if token exists\n    if (token) {\n      const headers = new HttpHeaders().set('Authorization', `Bearer ${token}`);\n      return this.http.post<{ message: string }>(`${this.API_URL}/auth/logout`, {}, { headers }).pipe(\n        timeout(this.REQUEST_TIMEOUT),\n        catchError((error: HttpErrorResponse) => {\n          console.warn('Error during server logout:', error);\n          // Don't throw error as local logout already succeeded\n          return of({ message: 'Logged out locally' });\n        })\n      );\n    }\n    \n    return of({ message: 'Logged out successfully' });\n  }\n\n  private getAuthHeaders(): HttpHeaders {\n    const token = this.getToken();\n    if (!token) {\n      throw new Error('No authentication token available');\n    }\n    return new HttpHeaders().set('Authorization', `Bearer ${token}`);\n  }\n\n  // Helper method for authenticated requests\n  getAuthenticatedHeaders(): HttpHeaders {\n    return this.getAuthHeaders();\n  }\n\n  // Helper method to handle API errors consistently\n  handleApiError(error: HttpErrorResponse): Observable<never> {\n    let errorMessage = 'An unexpected error occurred';\n    \n    if (error.error && typeof error.error === 'object') {\n      const apiError = error.error as ApiError;\n      errorMessage = apiError.message || errorMessage;\n      \n      // Log validation errors if present\n      if (apiError.errors) {\n        console.error('Validation errors:', apiError.errors);\n      }\n    } else if (error.message) {\n      errorMessage = error.message;\n    }\n    \n    console.error('API Error:', {\n      status: error.status,\n      message: errorMessage,\n      url: error.url\n    });\n    \n    return throwError(() => new Error(errorMessage));\n  }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;IAkBa;;;;;AAlBb;AACA;AACA;AACA;AAeO,IAAM,cAAN,MAAMA,aAAW;MAUF;MATH,UAAU;MACV,kBAAkB;;MAE3B,qBAAqB,IAAI,gBAA6B,IAAI;MAC3D,eAAe,KAAK,mBAAmB,aAAY;;MAGlD,YAA2B;MAEnC,YAAoB,MAAgB;AAAhB,aAAA,OAAA;AAClB,aAAK,kBAAiB;MACxB;MAEQ,oBAAiB;AAEvB,cAAM,QAAQ,KAAK,mBAAkB;AACrC,YAAI,OAAO;AACT,eAAK,YAAY;AACjB,eAAK,eAAc,EAAG,UAAU;YAC9B,OAAO,CAAC,UAAS;AACf,sBAAQ,KAAK,0CAA0C,KAAK;AAC5D,mBAAK,YAAW;YAClB;WACD;QACH;MACF;MAEQ,qBAAkB;AACxB,cAAM,OAAO;AACb,cAAM,gBAAgB,mBAAmB,SAAS,MAAM;AACxD,cAAM,KAAK,cAAc,MAAM,GAAG;AAClC,iBAAS,IAAI,GAAG,IAAI,GAAG,QAAQ,KAAK;AAClC,cAAI,IAAI,GAAG,CAAC;AACZ,iBAAO,EAAE,OAAO,CAAC,MAAM,KAAK;AAC1B,gBAAI,EAAE,UAAU,CAAC;UACnB;AACA,cAAI,EAAE,QAAQ,IAAI,MAAM,GAAG;AACzB,mBAAO,EAAE,UAAU,KAAK,QAAQ,EAAE,MAAM;UAC1C;QACF;AACA,eAAO;MACT;MAEA,WAAQ;AACN,eAAO,KAAK;MACd;MAEA,SAAS,OAAa;AACpB,YAAI,CAAC,SAAS,MAAM,KAAI,MAAO,IAAI;AACjC,kBAAQ,MAAM,yCAAyC;AACvD;QACF;AACA,aAAK,YAAY;MACnB;MAEA,cAAW;AACT,aAAK,YAAY;AAEjB,iBAAS,SAAS;MACpB;MAEA,kBAAe;AACb,cAAM,QAAQ,KAAK,SAAQ;AAC3B,eAAO,CAAC,CAAC,SAAS,MAAM,KAAI,MAAO;MACrC;MAEA,iBAAc;AACZ,cAAM,QAAQ,KAAK,SAAQ;AAC3B,YAAI,CAAC,OAAO;AACV,iBAAO,GAAG,IAAI;QAChB;AAEA,cAAM,UAAU,IAAI,YAAW,EAAG,IAAI,iBAAiB,UAAU,KAAK,EAAE;AAExE,eAAO,KAAK,KAAK,IAAU,GAAG,KAAK,OAAO,YAAY,EAAE,QAAO,CAAE,EAAE,KACjE,QAAQ,KAAK,eAAe,GAC5B,MAAM,CAAC,GACP,IAAI,UAAO;AACT,cAAI,MAAM;AACR,iBAAK,mBAAmB,KAAK,IAAI;UACnC;QACF,CAAC,GACD,WAAW,CAAC,UAA4B;AACtC,kBAAQ,MAAM,gCAAgC,KAAK;AAGnD,cAAI,MAAM,WAAW,OAAO,MAAM,WAAW,KAAK;AAChD,oBAAQ,KAAK,yCAAyC;AACtD,iBAAK,OAAM;UACb,WAAW,MAAM,WAAW,GAAG;AAC7B,oBAAQ,MAAM,2CAA2C;UAC3D,OAAO;AACL,oBAAQ,MAAM,qBAAqB,MAAM,OAAO;UAClD;AAEA,iBAAO,GAAG,IAAI;QAChB,CAAC,CAAC;MAEN;MAEA,MAAM,UAA6B;AACjC,YAAI,CAAC,YAAa,aAAa,YAAY,aAAa,UAAW;AACjE,kBAAQ,MAAM,2BAA2B,QAAQ;AACjD;QACF;AAEA,aAAK,gBAAgB,QAAQ;MAC/B;MAEQ,gBAAgB,UAAgB;AACtC,YAAI;AACF,iBAAO,SAAS,OAAO,GAAG,KAAK,QAAQ,QAAQ,QAAQ,EAAE,CAAC,yBAAyB,QAAQ;QAC7F,SAAS,OAAO;AACd,kBAAQ,MAAM,wCAAwC,KAAK;QAC7D;MACF;MAEA,qBAAkB;AAEhB,aAAK,eAAc,EAAG,UAAU;UAC9B,MAAM,CAAC,SAAQ;AACb,gBAAI,MAAM;AACR,sBAAQ,IAAI,oCAAoC,KAAK,KAAK;YAC5D;UACF;UACA,OAAO,CAAC,UAAS;AACf,oBAAQ,MAAM,6CAA6C,KAAK;AAChE,iBAAK,OAAM;UACb;SACD;MACH;MAEA,SAAM;AACJ,cAAM,QAAQ,KAAK,SAAQ;AAG3B,aAAK,YAAW;AAChB,aAAK,mBAAmB,KAAK,IAAI;AAGjC,YAAI,OAAO;AACT,gBAAM,UAAU,IAAI,YAAW,EAAG,IAAI,iBAAiB,UAAU,KAAK,EAAE;AACxE,iBAAO,KAAK,KAAK,KAA0B,GAAG,KAAK,OAAO,gBAAgB,CAAA,GAAI,EAAE,QAAO,CAAE,EAAE,KACzF,QAAQ,KAAK,eAAe,GAC5B,WAAW,CAAC,UAA4B;AACtC,oBAAQ,KAAK,+BAA+B,KAAK;AAEjD,mBAAO,GAAG,EAAE,SAAS,qBAAoB,CAAE;UAC7C,CAAC,CAAC;QAEN;AAEA,eAAO,GAAG,EAAE,SAAS,0BAAyB,CAAE;MAClD;MAEQ,iBAAc;AACpB,cAAM,QAAQ,KAAK,SAAQ;AAC3B,YAAI,CAAC,OAAO;AACV,gBAAM,IAAI,MAAM,mCAAmC;QACrD;AACA,eAAO,IAAI,YAAW,EAAG,IAAI,iBAAiB,UAAU,KAAK,EAAE;MACjE;;MAGA,0BAAuB;AACrB,eAAO,KAAK,eAAc;MAC5B;;MAGA,eAAe,OAAwB;AACrC,YAAI,eAAe;AAEnB,YAAI,MAAM,SAAS,OAAO,MAAM,UAAU,UAAU;AAClD,gBAAM,WAAW,MAAM;AACvB,yBAAe,SAAS,WAAW;AAGnC,cAAI,SAAS,QAAQ;AACnB,oBAAQ,MAAM,sBAAsB,SAAS,MAAM;UACrD;QACF,WAAW,MAAM,SAAS;AACxB,yBAAe,MAAM;QACvB;AAEA,gBAAQ,MAAM,cAAc;UAC1B,QAAQ,MAAM;UACd,SAAS;UACT,KAAK,MAAM;SACZ;AAED,eAAO,WAAW,MAAM,IAAI,MAAM,YAAY,CAAC;MACjD;;;;;AAhMW,kBAAW,WAAA;MAHvB,WAAW;QACV,YAAY;OACb;OACY,WAAW;;;",
  "names": ["AuthService"]
}
